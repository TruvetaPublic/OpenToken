#!/usr/bin/env python3
"""
Hash Calculator for OpenToken Secrets

This script calculates secure SHA-256 hashes for encryption and hashing secrets
used in the OpenToken processing flow. The hashes produced by this script
match those generated by the Java application.

Usage:
    python hash_calculator.py --hashing-secret "your-hashing-secret" --encryption-key "your-encryption-key"
    python hash_calculator.py --hashing-secret "HashingKey" --encryption-key "Secret-Encryption-Key-Goes-Here."

The script outputs the same SHA-256 hashes that are included in the metadata
file generated by the OpenToken Java application.
"""

import argparse
import hashlib
import sys
from typing import Optional


def calculate_secure_hash(input_string: str) -> str:
    """
    Calculates a secure SHA-256 hash of the given input.
    
    This method produces the same hash as the Java implementation:
    MessageDigest.getInstance("SHA-256").digest(input.getBytes(StandardCharsets.UTF_8))
    
    Args:
        input_string: The input string to hash
        
    Returns:
        The SHA-256 hash as a hexadecimal string
        
    Raises:
        ValueError: If input_string is None or empty
    """
    if not input_string:
        raise ValueError("Input string cannot be None or empty")
    
    # Calculate SHA-256 hash using UTF-8 encoding (same as Java StandardCharsets.UTF_8)
    hash_bytes = hashlib.sha256(input_string.encode('utf-8')).digest()
    
    # Convert to hexadecimal string (same format as Java implementation)
    return hash_bytes.hex()


def main():
    """Main function to handle command line arguments and calculate hashes."""
    parser = argparse.ArgumentParser(
        prog='hash_calculator.py',
        description='Calculate secure SHA-256 hashes for OpenToken secrets'
    )
    
    parser.add_argument(
        '--hashing-secret',
        help='The hashing secret to calculate hash for',
        dest='hashing_secret'
    )
    
    parser.add_argument(
        '--encryption-key',
        help='The encryption key to calculate hash for',
        dest='encryption_key'
    )
    
    parser.add_argument(
        '--output-format',
        choices=['json', 'table', 'simple'],
        default='table',
        help='Output format (default: table)'
    )
    
    # Parse arguments
    args = parser.parse_args()
    
    # Validate that at least one secret is provided
    if not args.hashing_secret and not args.encryption_key:
        print("Error: At least one of --hashing-secret or --encryption-key must be provided")
        parser.print_help()
        sys.exit(1)
    
    # Calculate hashes
    results = {}
    
    try:
        if args.hashing_secret:
            results['HashingSecretHash'] = calculate_secure_hash(args.hashing_secret)
        
        if args.encryption_key:
            results['EncryptionSecretHash'] = calculate_secure_hash(args.encryption_key)
    
    except ValueError as e:
        print(f"Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}")
        sys.exit(1)
    
    # Output results
    if args.output_format == 'json':
        import json
        print(json.dumps(results, indent=2))
    elif args.output_format == 'simple':
        for key, value in results.items():
            print(f"{value}")
    else:  # table format (default)
        print("OpenToken Secret Hashes")
        print("=" * 50)
        for key, value in results.items():
            print(f"{key:20}: {value}")
        print("=" * 50)
        print("These hashes match those generated by the Java OpenToken application")


if __name__ == "__main__":
    main()
